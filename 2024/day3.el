(defmacro inc! (var) `(progn (setq ,var (+ ,var 1)) ,var))
(defmacro return (code) `(throw 'return ,code))
(defmacro try-substring (str start &optional end)
  (if end
      `(if (< (length ,str) (- ,end ,start)) "" (substring ,str ,start ,end))
    `(if (< (length ,str) ,start) "" (substring ,str ,start))))

(defun solve-program (input parse-conditionnals?)
  (defun parse-num (str)
    (defmacro return-num (i) `(return (cons (substring str ,i) (string-to-number (substring str 0 ,i)))))
    (catch 'return
      (if (cl-digit-char-p (elt str 0))
          (if (cl-digit-char-p (elt str 1))
              (if (cl-digit-char-p (elt str 2))
                  (return-num 3)
                (return-num 2))
            (return-num 1))
        nil)))
  (defun parse-mul (str)
    (and (>= (length str) 8)
         (string= (substring str 0 4) "mul(")
         (let* ((n1 (parse-num (substring str 4))))
           (and n1
                (eq (elt (car n1) 0) ?,)
                (let* ((n2 (parse-num (substring (car n1) 1))))
                  (and n2
                       (eq (elt (car n2) 0) ?\))
                       (cons (substring (car n2) 1) (* (cdr n1) (cdr n2)))))))))
  (defun parse-do (str) (string= (try-substring str 0 4) "do()"))
  (defun parse-dont (str) (string= (try-substring str 0 7) "don't()"))
  (let ((i 0)
        (str input)
        (sum 0)
        (active? t))
    (while (< i (length input))
      (let* ((newstr (try-substring str i))
             (res (parse-mul newstr)))
        (cond (res (progn (setq str (car res))
                          (if active? (setq sum (+ sum (cdr res))))
                          (setq i 0)))
              ((and parse-conditionnals? (parse-do newstr)) (progn (setq i (+ i 4))
                                                                   (setq active? t)))
              ((and parse-conditionnals? (parse-dont newstr)) (progn (setq i (+ i 7))
                                                                     (setq active? nil)))
              (t (inc! i)))))
    sum))

(defun solve (input-file)
  (defun current-line () (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
  (let* ((input (if (file-exists-p input-file)
                    (with-temp-buffer (insert-file-contents input-file)
                                      (buffer-string))
                  (error "Could not find file %s" input-file))))
    (let* ((part1 (solve-program input nil))
           (part2 (solve-program input t)))
      (message "part1: %s | part2: %s" part1 part2))))

;;(solve (concat (file-name-base (file-name-nondirectory (buffer-file-name (current-buffer)))) ".testinput"))
(solve (concat (file-name-base (file-name-nondirectory (buffer-file-name (current-buffer)))) ".input"))


