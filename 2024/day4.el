(defmacro inc! (var) `(progn (setq ,var (+ ,var 1)) ,var))
(defmacro let? (var val code) `(let ((,var ,val)) (and ,var ,code)))

(defun find-puzzle-stride (str)
  (let ((i 0) (count (length str))) (catch 'return (while (< i count)
                                                     (if (eq (elt str i) ?\n) (throw 'return (+ i 1))
                                                       (inc! i))))))
(defun find-adj-i (str i dx dy stride)
  (let* ((h (+ 1 (/ (length str) stride)))
         (x (mod i stride))
         (y (/ i stride))
         (new-dx (+ x dx))
         (new-dy (+ y dy))
         (adj-i (+ (* (+ y dy) stride) x dx)))
    (if (or (>= adj-i (length str))
            (< new-dx 0) (>= new-dx stride)
            (< new-dy 0) (>= new-dy h))
        nil
      adj-i)))

(defun next-letter (letter) (cond ((eq letter ?X) ?M)
                                  ((eq letter ?M) ?A)
                                  ((eq letter ?A) ?S)
                                  (t nil)))

(defun try-find-word (str i letter dx dy stride)
  ;;(message (format "(try-find-word %d %c %c)" i (or letter ?O) (elt str i)))
  (or (not letter)
      (and (eq (elt str i) letter)
           (let ((nextletter (next-letter letter)))
             (or (not nextletter)
                 (let? next-i (find-adj-i str i dx dy stride)
                       (try-find-word str next-i nextletter dx dy stride)))))))

(defun get-word-indices (str x dx dy stride)
  (let* ((m (find-adj-i str x dx dy stride))
         (a (find-adj-i str m dx dy stride))
         (s (find-adj-i str a dx dy stride)))
   (list x m a s )))

(defun solve1 (input)
  (let ((stride (find-puzzle-stride input))
        (i 0)
        (count (length input))
        (word-count 0)
        (dict '()))
    (while (< i count)
      (seq-doseq (dx '(-1 0 1))
        (seq-doseq (dy '(-1 0 1))
          (and (or (not (= dx 0)) (not (= dy 0)))
               (try-find-word input i ?X dx dy stride)
               (setq dict (append dict (get-word-indices input i dx dy stride)))
               (inc! word-count))))
      (inc! i))

    ;; (let* ((test 93) (i (+ test (/ test 10))))
    ;;   (message (format "test: %s" (try-find-word input i ?X -1 -1 stride)))
    ;;   (setf (elt input i) ?.)
    ;;   (message input))
    
    ;; (message (concat "" (seq-map-indexed (lambda (x i) (if (or (eq x ?\n)
    ;;                                                            (seq-find (lambda (index) (= i index)) dict))
    ;;                                                        x
    ;;                                                      ?.))
    ;;                                      input)))
    word-count))

(defun try-find-x (str i stride)
  (and (eq (elt str i) ?A)
       (let ((ul (find-adj-i str i -1 -1 stride))
             (ur (find-adj-i str i 1 -1 stride))
             (dl (find-adj-i str i -1 1 stride))
             (dr (find-adj-i str i 1 1 stride)))
         (and ul ur dl dr
              (or (if (eq (elt str ul) ?M) (eq (elt str dr) ?S))
                  (if (eq (elt str ul) ?S) (eq (elt str dr) ?M)))
              (or (if (eq (elt str ur) ?M) (eq (elt str dl) ?S))
                  (if (eq (elt str ur) ?S) (eq (elt str dl) ?M)))))))

(defun solve2 (input)
  (let ((stride (find-puzzle-stride input))
        (i 0)
        (count (length input))
        (x-count 0))
    (while (< i count)
      (and (try-find-x input i stride)
           (inc! x-count))
      (inc! i))
    x-count))

(defun solve (input-file)
  (defun current-line () (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
  (let* ((input (if (file-exists-p input-file)
                    (with-temp-buffer (insert-file-contents input-file)
                                      (buffer-string))
                  (error "Could not find file %s" input-file))))
    (let* ((part1 (solve1 input))
           (part2 (solve2 input)))
      (message "part1: %s | part2: %s" part1 part2))))

;;(solve (concat (file-name-base (file-name-nondirectory (buffer-file-name (current-buffer)))) ".testinput"))
(solve (concat (file-name-base (file-name-nondirectory (buffer-file-name (current-buffer)))) ".input"))


