(defmacro inc! (var) `(progn (setq ,var (+ ,var 1)) ,var))
(defmacro dec! (var) `(progn (setq ,var (- ,var 1)) ,var))

(defun is-safe (report)
  (defun is-pair-safe? (v1 v2 sign)
    (let* ((diff (- v1 v2))
           (diff-sign (cl-signum diff)))
      (and (or (not sign) (= sign diff-sign))
                (>= (abs diff) 1)
                (<= (abs diff) 3))))
  (defun is-report-safe? (report)
    (catch 'return (let ((count (- (length report) 1))
                         (sign (cl-signum (- (elt report 0) (elt report 1)))))
                     (dotimes (i count)
                       (if (not (is-pair-safe? (elt report i) (elt report (+ i 1)) sign))
                           (throw 'return nil))))
           t))
  (or (is-report-safe? report)
      (and (= tolerance 1)
           (let ((i 0)
                 (count (length report)))
             (catch 'break
               (dotimes (i count)
                 (if (is-report-safe? (seq-remove-at-position report i))
                     (throw 'break t)))
               nil)))))

(defun solve1 (input)
  (let ((tolerance 0)) (seq-count (lambda (x) x) (mapcar 'is-safe input))))

(defun solve2 (input)
  (let ((tolerance 1)) (seq-count (lambda (x) x) (mapcar 'is-safe input))))

(defun solve (input-file)
  (defun current-line () (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
  (let* ((input (if (file-exists-p input-file)
                    (with-temp-buffer (insert-file-contents input-file)
                                      (beginning-of-buffer)
                                      (let ((data '()))
                                        (while (< (point) (point-max))
                                          (push (mapcar 'string-to-number (split-string (current-line)))
                                                data)
                                          (forward-line))
                                        data))
                  (error "Could not find file %s" input-file))))
    (let* ((part1 (solve1 input))
           (part2 (solve2 input)))
      (message "part1: %s | part2: %s" part1 part2))))

(solve "day2.testinput")
(solve "day2.input")


