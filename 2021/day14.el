(defun simulate (polymer rules)
  (let ((new-polymer '())
        (last-atom nil))
    (dotimes (atom-index (1- (length polymer)))
      (let* ((atom-1 (seq-elt polymer atom-index))
             (atom-2 (seq-elt polymer (1+ atom-index)))
             (rule (assoc (list atom-1 atom-2) rules)))
        (push atom-1 new-polymer)
        (if rule (push (second rule) new-polymer))
        (setq last-atom atom-2)))
    (seq-reverse (cons last-atom new-polymer))))

(defun find-all-atoms (rules)
  (seq-uniq (seq-mapcat (lambda (r) (cons (second r) (first r)))
                        rules)))

(defun run-sim (polymer rules iteration-count)
  (let ((results (seq-map (lambda (atom) (list atom 0)) (find-all-atoms rules))))

    (dotimes (step-index iteration-count)
      (message "sim step %d" step-index)
      (setq polymer (simulate polymer rules))
      (let ((results-copy (copy-tree results)))
        (seq-doseq (atom polymer)
          (let ((res (assoc atom results)))
            (setf (second res) (1+ (second res)))))
                                        ;(message "polymer: %s " (seq-reduce 'concat (seq-map 'symbol-name polymer) ""))
                                        ;(message "results: %s" results)
        ))

    (seq-doseq (atom polymer)
      (let ((res (assoc atom results)))
        (setf (second res) (1+ (second res)))))

    (let ((min-max (seq-reduce (lambda (acc r) (let ((min (first acc))
                                                     (max (second acc)))
                                                 (list (if (< (second r) (second min))
                                                           r min)
                                                       (if (> (second r) (second max))
                                                           r max))))
                               results
                               `((_ ,most-positive-fixnum) (_ ,most-negative-fixnum)))))
      (message "results: %s" results)
      (- (second (second min-max)) (second (first min-max))))))

(defun solve-part1 (polymer rules)
  (run-sim polymer rules 10))

(defun solve-part2 (polymer rules)
  (defmacro inc-dict (pair dict delta)
    (let ((cell-sym (gensym)))
      `(let ((,cell-sym (assoc ,pair ,dict)))
         (if (not ,cell-sym) (error "missing cell for %s" ,pair))
         (setf (third ,cell-sym) (+ (third ,cell-sym) ,delta)))))
  
  (let ((results (seq-map (lambda (atom) (list atom 0)) (find-all-atoms rules)))
        (dict (seq-map (lambda (rule) (list (first rule) (second rule) 0)) rules)))

    (dotimes (i (1- (length polymer)))
      (let ((r1 (seq-elt polymer i))
            (r2 (seq-elt polymer (1+ i))))
        (inc-dict (list r1 r2) dict 1)))
    (message "init dictionary: %s" dict)

    (dotimes (step-index 40)
      ;;(message "------------------------------\nsim step %d" step-index)
      (dolist (pair-data (copy-tree dict))
        (seq-let ((r1 r2) r3 count) pair-data
          (if (> count 0)
              (progn ;;(message "rule: %s" pair-data)
                     (inc-dict (list r1 r2) dict (- count))
                     (inc-dict (list r1 r3) dict count)
                     (inc-dict (list r3 r2) dict count)))))
      ;;(message "dict: %s" dict)
      )

    (seq-doseq (pair-data dict)
      (seq-let ((r1 r2) _ count) pair-data
        (let ((res (assoc r1 results))
              (delta (if (or (eq r1 (first polymer)) (eq r1 (last polymer))) 1 0)))
          (setf (second res) (+ (second res) (/ count 2))))
        (let ((res (assoc r2 results))
              (delta (if (or (eq r2 (first polymer)) (eq r2 (last polymer))) 1 0)))
          (setf (second res) (+ (second res) (/ count 2))))))

    (let ((min-max (seq-reduce (lambda (acc r) (let ((min (first acc))
                                                     (max (second acc)))
                                                 (list (if (< (second r) (second min))
                                                           r min)
                                                       (if (> (second r) (second max))
                                                           r max))))
                               results
                               `((_ ,most-positive-fixnum) (_ ,most-negative-fixnum)))))
      ;;(message "results: %s | min-max: %s" results min-max)
      (- (second (second min-max)) (second (first min-max))))))

(defun solve (input-file)
  (let* ((input (if (file-exists-p input-file)
                    (with-temp-buffer
                      (insert-file-contents input-file)
                      (let ((init-polymer (seq-map (lambda (x) (intern (string x)))
                                                   (buffer-substring-no-properties (line-beginning-position)
                                                                                   (line-end-position))))
                            (rules '()))
                        (forward-line 2)
                        (beginning-of-line)
                        (while (not (eobp))
                          (let ((r1 (intern (string (char-after (point)))))
                                (r2 (intern (string (char-after (1+ (point))))))
                                (r3 (intern (string (char-after (+ (point) 6))))))
                            (push (list (list r1 r2) r3) rules)
                            (forward-line)))
                        (list init-polymer rules)))
                  (message (concat "Could not find file " input-file)))))
    (let* ((initial-polymer (first input))
           (rules (second input))
           (part1 (solve-part1 (copy-tree initial-polymer) (copy-tree rules)))
           (part2 (solve-part2 initial-polymer rules)))
      (message "part1: %s | part2: %s" part1 part2))))

(solve "day14-test-input.txt")
(solve "day14-input.txt")
