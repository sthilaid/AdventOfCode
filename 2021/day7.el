(defun find-min-max (positions)
  (seq-reduce (lambda (acc p) (let* ((acc-min (first acc))
                                     (acc-max (second acc))
                                     (min (if (< p acc-min) p acc-min))
                                     (max (if (> p acc-max) p acc-max)))
                                (list min max)))
              positions
              (list most-positive-fixnum most-negative-fixnum)))

(defun find-cheapest-position (positions generate-cost-table-fun)
  (let ((min-max (find-min-max positions)))
    (let* ((min (first min-max))
           (max (second min-max))
           (delta (- max min))
           (cost-table (funcall generate-cost-table-fun (+ delta 1)))
           (best-distance most-positive-fixnum)
           (best-target 0))
      (dotimes (i delta)
        (let* ((target (+ min i))
               (total-dist-to-target (seq-reduce (lambda (acc pos) (+ acc (seq-elt cost-table (abs (- target pos)))))
                                                 positions
                                                 0)))
          (if (< total-dist-to-target best-distance)
              (progn (setq best-distance total-dist-to-target)
                     (setq best-target target)))))
      best-distance)))

(defun solve-part1 (positions)
  (defun cost-table-gen (delta)
    (let ((table (make-vector delta 0)))
      (dotimes (i delta) (aset table i i))
      table))
  (find-cheapest-position positions 'cost-table-gen))

(defun solve-part2 (positions)
  (defun cost-fun (delta) (cond ((<= delta 0)   0)
                                ((= delta 1)    1)
                                (t              (+ delta (cost-fun (- delta 1))))))
  (defun cost-table-gen (delta)
    (let ((table (make-vector delta 0)))
      (dotimes (i delta)
        (aset table i (cost-fun i)))
      table))
  (find-cheapest-position positions 'cost-table-gen))

(defun solve (input-file)
  (let ((input-string (if (file-exists-p input-file)
                          (with-temp-buffer
                            (insert-file-contents input-file)
                            (buffer-string))
                        (message (concat "Could not find file " input-file)))))
    (let* ((positions (mapcar 'string-to-number (split-string input-string ",")))
           (part1 (solve-part1 positions))
           (part2 (solve-part2 positions)))
      (format "part1: %d | part2: %d" part1 part2))))

(solve "day7-test-input.txt")
(solve "day7-input.txt")
