(setq standard-data '("abcefg" "cf" "acdeg" "acdfg" "bcdf" "abdfg" "abdefg" "acf" "abcdefg" "abcdfg"))

(defun parse-tokenized-input (tokens)
  (mapcar (lambda (tokens)
            (let ((dataset '())
                  (input '())
                  (found-seperator? nil))
              (dolist (token tokens)
                (cond ((string= token "|")  (setq found-seperator? t))
                      (found-seperator?     (push token input))
                      (t                    (push token dataset))))
              (if (not (= (length dataset) 10))
                  (error (format "invalid dataset: %s" dataset)))
              (if (not (= (length input) 4))
                  (error (format "invalid input: " input)))
              (list dataset (seq-reverse input))))
          tokens))

(defun count-unique-patterns (input)
  (defun is-unique-pattern (s) (or (= (length s) 2) (= (length s) 3) (= (length s) 4) (= (length s) 7)))
  (seq-count 'is-unique-pattern input))

(defun solve-part1 (all-data)
  (seq-reduce (lambda (sum data) (+ sum (count-unique-patterns (elt data 1)))) all-data 0))

(defun find-mapping (dataset)
  (let* ((one   (seq-find (lambda (pattern) (= 2 (length pattern))) dataset))
         (four  (seq-find (lambda (pattern) (= 4 (length pattern))) dataset))
         (seven (seq-find (lambda (pattern) (= 3 (length pattern))) dataset))
         (eight (seq-find (lambda (pattern) (= 7 (length pattern))) dataset))
         (one-0 (elt one 0))
         (one-1 (elt one 1))
         (cf    (if (= (seq-count (lambda (pat) (seq-contains-p pat one-0)) dataset)
                       8)
                    (list one-0 one-1)
                  (list one-1 one-0)))
         (a     (seq-find (lambda (letter) (not (seq-contains-p one letter))) seven))
         (four-bd (seq-filter (lambda (letter) (not (seq-contains-p one letter))) four))
         (bd    (if (= (seq-count (lambda (pat) (seq-contains-p pat (first four-bd))) dataset)
                       6)
                    (list (first four-bd) (second four-bd))
                  (list (second four-bd) (first four-bd))))
         (eight-eg (seq-filter (lambda (letter) (not (seq-contains-p (append cf (list a) bd) letter))) eight))
         (eg    (if (= (seq-count (lambda (pat) (seq-contains-p pat (first eight-eg))) dataset)
                       4)
                    (list (first eight-eg) (second eight-eg))
                  (list (second eight-eg) (first eight-eg)))))
    `(("a" ,a) ("b" ,(first bd)) ("c" ,(first cf)) ("d" ,(second bd))
      ("e" ,(first eg)) ("f" ,(second cf)) ("g" ,(second eg)))))

(defun decode-number (mapping coded-pattern)
  (defun translate (coded-letter)
    (first (seq-find (lambda (m) (equal coded-letter (second m))) mapping)))
  (seq-position standard-data (apply 'concat (sort (mapcar 'translate coded-pattern) 'string<))))

(defun build-number (digits)
  (seq-reduce (lambda (num digit) (+ (* num 10) digit)) digits 0))

(defun solve-data-number (data)
  (let* ((dataset (elt data 0))
         (inputs (elt data 1))
         (mapping (find-mapping dataset))
         (digits (mapcar (lambda (in) (decode-number mapping in)) inputs))
         (number (build-number digits)))
    ;(message (format "%s -> %d" inputs number))
    number))

(defun solve-part2 (all-data)
  (seq-reduce (lambda (sum data) (+ sum (solve-data-number data))) all-data 0))

(defun solve (input-file)
  (let ((input-string (if (file-exists-p input-file)
                          (with-temp-buffer
                            (insert-file-contents input-file)
                            (buffer-string))
                        (message (concat "Could not find file " input-file)))))
    (let* ((tokens (mapcar (lambda (s) (split-string s " "))
                           (seq-filter (lambda (s) (not (string= s "")))
                                       (split-string input-string "\n"))))
           (datasets (parse-tokenized-input tokens))
           (part1 (solve-part1 datasets))
           (part2 (solve-part2 datasets)))
      (format "part1: %d | part2: %d" part1 part2))))

(solve "day8-test-input.txt")
(solve "day8-input.txt")
