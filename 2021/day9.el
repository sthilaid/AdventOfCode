(defun get-index (x y width) (+ x (* y width)))
(defun print-grid (grid w h)
  (let ((str ""))
    (dotimes (y h)
      (dotimes (x w) (setq str (concat str (format " %3s" (aref grid (get-index x y w))))))
      (setq str (concat str "\n")))
    (message str)))

(defun get-neighbours (x y grid width height)
  (let ((neighbours '()))
    (if (< (1+ x) width)    (push (let ((idx (get-index (1+ x) y width))) (cons idx (aref grid idx))) neighbours))
    (if (>= (1- x) 0)       (push (let ((idx (get-index (1- x) y width))) (cons idx (aref grid idx))) neighbours))
    (if (< (1+ y) height)   (push (let ((idx (get-index x (1+ y) width))) (cons idx (aref grid idx))) neighbours))
    (if (>= (1- y) 0)       (push (let ((idx (get-index x (1- y) width))) (cons idx (aref grid idx))) neighbours))
    neighbours))

(defun solve-part1 (width height grid)
  (let ((minima '()))
    (dotimes (x width)
      (dotimes (y height)
        (let* ((index (get-index x y width))
               (value (aref grid index))
               (neighbours (get-neighbours x y grid width height))
               (is-minimum (seq-every-p (lambda (n) (< value n)) (mapcar 'cdr neighbours))))
          (if is-minimum
              (push value minima)))))
    (seq-reduce (lambda (acc m) (+ acc (1+ m))) minima 0)))

(defun solve-part2 (width height grid)
  (defmacro get-next-bassin-id ()
    `(progn (setq next-bassin-id (1+ next-bassin-id))
            next-bassin-id))

  (defun is-valid-bassin-location (index value bassin-map)
    (and (not (aref bassin-map index)) (< value 9)))
  
  (defun propagate (grid bassin-map x y id)
    (let* ((neighbours (get-neighbours x y grid width height))
           (valid-neighbours (seq-filter (lambda (n) (is-valid-bassin-location (car n) (cdr n) bassin-map))
                                         neighbours)))
      (aset bassin-map (get-index x y width) id)
      (seq-doseq (n valid-neighbours)
        (let* ((n-index (car n))
               (n-x (% n-index width))
               (n-y (/ n-index width)))
          (propagate grid bassin-map n-x n-y id)))))
  (let ((next-bassin-id 0)
        (bassin-map (make-vector (length grid) nil)))
    (dotimes (x width)
      (dotimes (y height)
        (let* ((index (get-index x y width))
               (value (aref grid index)))
          (if (is-valid-bassin-location index value bassin-map)
              (let ((bassin-id (get-next-bassin-id)))
                (propagate grid bassin-map x y bassin-id))))))
    (let ((bassin-counts (make-vector (1+ next-bassin-id) 0)))
      (seq-doseq (id bassin-map)
        (if id (aset bassin-counts id (1+ (aref bassin-counts id)))))
      (seq-reduce '* (seq-take (sort bassin-counts '>) 3) 1))))

(defun solve (input-file)
  (let* ((grid-data (let ((grid-size 0)
                              (grid nil))
                          (if (file-exists-p input-file)
                              (with-temp-buffer
                                (insert-file-contents input-file)
                                (beginning-of-buffer)
                                (setq grid-width (1- (line-end-position)))
                                (setq grid-height (count-lines (point-min) (point-max)))
                                (setq grid (make-vector (* grid-width grid-height) 0))
                                (let ((index 0))
                                  (while (not (eobp))
                                    (let ((c (char-after (point))))
                                      (if (not (eq c ?\n))
                                          (progn (aset grid index (string-to-number (string c)))
                                                 (setq index (1+ index)))))
                                    (forward-char)))
                                (list grid-width grid-height grid))
                            (message (concat "Could not find file " input-file))))))
    (let* ((width (first grid-data))
           (height (second grid-data))
           (grid (third grid-data))
           (part1 (solve-part1 width height grid))
           (part2 (solve-part2 width height grid)))
      (message "part1: %s | part2: %s" part1 part2))))

(solve "day9-test-input.txt")
(solve "day9-input.txt")
