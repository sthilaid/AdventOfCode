(defun build-adjacencies (cave-system)
  (let ((adjacencies '()))
    (dolist (edge cave-system)
      (let* ((cave1 (first edge))
             (cave2 (second edge))
             (cave1-data (assoc cave1 adjacencies))
             (cave2-data (assoc cave2 adjacencies)))
        (if (not cave1-data) (let ((data (list cave1 '())))
                               (push data adjacencies)
                               (setq cave1-data data)))
        (if (not cave2-data) (let ((data (list cave2 '())))
                               (push data adjacencies)
                               (setq cave2-data data)))
        (push cave2 (second cave1-data))
        (push cave1 (second cave2-data))))
    adjacencies))

(defun is-big? (cave)
  (string= (upcase cave) cave))

(defun solve-part1 (cave-system)
  (let ((adjacencies (build-adjacencies cave-system))
        (current-paths '(("start")))
        (new-paths '())
        (valid-paths '()))
    (while (not (seq-empty-p current-paths))
      (dolist (path current-paths)
        (let ((adjacent-caves (second (assoc (first path) adjacencies))))
          (dolist (cave adjacent-caves)
            (if (string= cave "end")
                (push (seq-reverse (cons cave path)) valid-paths)
              (if (or (is-big? cave) (not (member cave path)))
                (push (cons cave (copy-sequence path)) new-paths))))))
      (setq current-paths new-paths)
      (setq new-paths '()))
    (length valid-paths)))

(defun solve-part2-faster (cave-system)
  (defconst double-smallcave-mark "**doublemark**")
  (defun is-valid-small? (cave) (and (not (string= cave "start"))
                                     (not (string= cave "end"))))
  (defun can-go-through? (cave path)
    (cond ((not (is-valid-small? cave)) nil)
          ((is-big? cave) t)
          ((not (member cave path)) t)
          (t nil)))
  (defun is-marked? (path) (member double-smallcave-mark path))
  (defmacro mark-path (path) `(setf ,path (seq-reverse (cons double-smallcave-mark
                                                             (seq-reverse ,path)))))
  
  (let ((adjacencies (build-adjacencies cave-system))
        (current-paths '(("start")))
        (new-paths '())
        (valid-paths '()))
    (while (not (seq-empty-p current-paths))
      (dolist (path current-paths)
        (let ((adjacent-caves (second (assoc (first path) adjacencies))))
          (dolist (cave adjacent-caves)
            (if (string= cave "end")
                (push (seq-reverse (cons cave path)) valid-paths)
              (if (can-go-through? cave path)
                  (push (cons cave (copy-sequence path)) new-paths)
                (if (and (not (is-marked? path))
                         (is-valid-small? cave))
                    (let ((path-copy (copy-sequence path)))
                      (mark-path path-copy)
                      (push (cons cave path-copy) new-paths))))))))
      (setq current-paths new-paths)
      (setq new-paths '()))
    (length valid-paths)))

(defun solve (input-file)
  (let* ((cave-system(if (file-exists-p input-file)
                         (with-temp-buffer
                           (insert-file-contents input-file)
                           (seq-map (lambda (x) (split-string x "-"))
                                    (seq-filter (lambda (x) (not (string= x "")))
                                                (split-string (buffer-string) "\n"))))
                       (message (concat "Could not find file " input-file)))))
    (let* ((part1 (solve-part1 cave-system))
           (part2 (solve-part2-faster cave-system)))
      (message "part1: %s | part2: %s" part1 part2))))

(defmacro time-call (call) (let ((s (gensym))) `(let ((,s (float-time)))
                                                  ,call
                                                  (message "time: %.2f" (- (float-time) ,s)))))
(solve "day12-test-small-input.txt")
(solve "day12-test-medium-input.txt")
(solve "day12-test-long-input.txt")
(solve "day12-input.txt")
