(defconst bignum 1000)

(defun get-neighbours (i)
  (defmacro try-add-neighbour (dx dy)
    (let ((xsym (gensym)) (ysym (gensym)))
      `(let ((,xsym (+ x ,dx)) (,ysym (+ y ,dy)))
         (if (and (>= ,xsym 0) (< ,xsym 10) (>= ,ysym 0) (< ,ysym 10))
             (push (+ ,xsym (* ,ysym 10)) neighbours)))))
  (let ((neighbours '())
        (x (% i 10))
        (y (/ i 10)))
    (try-add-neighbour 0 1)
    (try-add-neighbour 1 0)
    (try-add-neighbour 1 1)
    (try-add-neighbour 0 -1)
    (try-add-neighbour -1 0)
    (try-add-neighbour -1 -1)
    (try-add-neighbour -1 1)
    (try-add-neighbour 1 -1)
    neighbours))

(defun print-grid (grid flash-count sim-index)
  (let ((str (format "---------------------------\nSim Iteration %d\n\n" sim-index)))
    (dotimes (y 10)
      (dotimes (x 10)
        (let* ((index (+ x (* y 10)))
               (value (aref grid index)))
          (setq str (concat str (format "%s " (if (> value 1000) "X" value))))))
      (setq str (concat str "\n")))
    (setq str (concat str (format "flash count: %d" flash-count)))
    (let ((message-log-max 10000))
      (message str))))

(defun simulation-step (grid)
  (defmacro get-grid (index) `(aref grid ,index))
  (defmacro inc-grid (index) `(aset grid ,index (1+ (aref grid ,index))))
  (defmacro try-flash-grid (index) (let ((value-sym (gensym)))
                                     `(let ((,value-sym (aref grid ,index)))
                                        (if (and (> ,value-sym 9) (< ,value-sym ,bignum))
                                            (progn (aset grid ,index ,bignum)
                                                   (setq flash-count (1+ flash-count))
                                                   t)
                                          nil))))
  (let ((prev-flash-count -1)
        (flash-count 0))
    (dotimes (i 100)
      (inc-grid i))

    (while (not (= prev-flash-count flash-count))
      (setq prev-flash-count flash-count)
      (dotimes (i 100)
        (if (try-flash-grid i)
            (let ((neighbours (get-neighbours i)))
              (dolist (n neighbours)
                (inc-grid n))))))
    (dotimes (i 100)
      (let ((power (aref grid i)))
        (if (>= power bignum)
            (aset grid i 0))))
    flash-count))

(defun solve-part1 (grid)
  (let ((total-flash-count 0))
    (dotimes (sim-step-index 100)
      (let ((flash-count (simulation-step grid)))
        ;;(print-grid grid flash-count (1+ sim-step-index))
        (setq total-flash-count (+ total-flash-count flash-count))))
    total-flash-count))

(defun solve-part2 (grid)
  (catch 'done
    (dotimes (sim-step-index 10000)
      (let ((flash-count (simulation-step grid)))
        (if (= flash-count 100)
            (throw 'done (1+ sim-step-index)))))
    10000))

(defun solve (input-file)
  (let* ((grid (make-vector 100 0))
         (lines (if (file-exists-p input-file)
                    (with-temp-buffer
                      (insert-file-contents input-file)
                      (let ((i 0))
                        (beginning-of-buffer)
                        (while (and (not (eobp)) (< i 100))
                          (let ((c (following-char)))
                            (if (not (eq c ?\n))
                                (progn (aset grid i (string-to-number (string c)))
                                       (setq i (1+ i)))))
                          (forward-char))))
                  (message (concat "Could not find file " input-file)))))
    (let* ((grid-copy (copy-sequence grid))
           (part1 (solve-part1 grid))
           (part2 (solve-part2 grid-copy)))
      (message "part1: %s | part2: %s" part1 part2))))

(solve "day11-test-input.txt")
(solve "day11-input.txt")
