;;; ...  -*- lexical-binding: t -*-

(defun parse (input)
  (let ((width (seq-position input ?\n))
        (oneline-input (concat (seq-filter (lambda (x) (not (eq x ?\n))) input))))
    (cons width oneline-input)))

(defun get-value (width layout x y)
  (and (>= x 0) (>= y 0)
       (< x width) (< y width)
       (eq ?@ (elt layout (+ (* y width) x)))))

(defun inc-if (x test) (if test (1+ x) x))

(defun is-accessible? (width layout x y)
  (and (get-value width layout x y)
       (named-let check-around ((dx -1)
                                (dy -1)
                                (neighbour-count 0))
         (cond ((> dy 1) (< neighbour-count 4))
               ((> dx 1) (check-around -1 (1+ dy) neighbour-count))
               ((and (= dx 0) (= dy 0))
                (check-around (1+ dx) dy neighbour-count))
               (t (check-around (1+ dx) dy (inc-if neighbour-count (get-value width layout (+ x dx) (+ y dy)))))))))

(defun iterate (width layout)
  (let ((next-layout (copy-sequence layout)))
    (named-let count-rows ((y 0)
                           (count 0))
      (if (>= y width)
          (list count next-layout)
        (let ((increase (named-let count-col ((x 0)
                                              (col-count 0))
                          (if (>= x width)
                              col-count
                            (let ((can-remove? (is-accessible? width layout x y)))
                              (if can-remove? (aset next-layout (+ (* width y) x) ?x))
                              (count-col (1+ x) (inc-if col-count can-remove?)))))))
          (count-rows (1+ y) (+ count increase)))))))

(defun solve1 (inputs)
  (let ((width (car inputs))
        (layout (cdr inputs)))
    (car (iterate width layout))))

(defun solve2 (inputs)
  (let ((width (car inputs))
        (layout (cdr inputs)))
    (named-let cleanup ((layout layout)
                        (prev-removed-count nil)
                        (removed-count 0)
                        (iteration-count 0))
      (message "iteration %s: count: %s" iteration-count removed-count)
      (if (and prev-removed-count (= removed-count prev-removed-count))
          removed-count
        (pcase (iterate width layout)
          (`(,count ,new-layout)
           (cleanup new-layout removed-count (+ removed-count count) (1+ iteration-count)))
          (`,val (error "oops: %s" val)))))))

(defun solve (input-file)
  (let* ((input (if (file-exists-p input-file)
                    (with-temp-buffer (insert-file-contents input-file)
                                      (buffer-string))
                  (error "Could not find file %s" input-file))))
    (let* ((now (float-time))
           (parsed-input (parse input))
           (part1 (solve1 parsed-input))
           (part2 (solve2 parsed-input)))
      (message "part1: %s | part2: %s (evaluated in %.3f sec)" part1 part2 (- (float-time) now)))))

(let* ((read-answer-short t)
       (answer (read-answer "run testinput or input?" '(("testinput" ?t "run test input") ("input" ?i "run input")))))
  (let ((w (if (string= answer "testinput") 11 101))
        (h (if (string= answer "testinput") 7 103)))
    (solve (concat (file-name-base (file-name-nondirectory (buffer-file-name (current-buffer)))) "." answer))))
